#!dotnet run

// this is a script file intended to be ran using dotnet run (new feature in dotnet 10 preview 4)
#:property ManagePackageVersionsCentrally=false
#:package Microsoft.CodeAnalysis.CSharp@4.8.0
#:package Microsoft.CodeAnalysis.CSharp.Workspaces@4.8.0

using System.Diagnostics;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Formatting;

var isWindows = OperatingSystem.IsWindows();

var compilerPath = isWindows
    ? Path.Combine("bin", "kaitai-struct-compiler.bat")
    : Path.Combine("bin", "kaitai-struct-compiler");

if (!File.Exists(compilerPath))
{
    throw new FileNotFoundException(
        $"Could not find kaitai-struct-compiler at {compilerPath}."
    );
}

var path = args.FirstOrDefault() ?? Directory.GetCurrentDirectory();

Console.WriteLine($"Path: {path}");

var attributes = File.GetAttributes(path);
var isDirectory = attributes.HasFlag(FileAttributes.Directory);

// if the provided args is a directory, we just go through all ksy files inside the directory
var keyFiles = isDirectory
    ? Directory.GetFileSystemEntries(path, "*.ksy", SearchOption.AllDirectories)
    : [path];

var processStartInfo = new ProcessStartInfo
{
    FileName = compilerPath,
    UseShellExecute = false,
    CreateNoWindow = true,
    RedirectStandardOutput = true,
    RedirectStandardError = true
};

foreach (var ksyFilePath in keyFiles)
{
    Console.WriteLine($"Generating code for: {ksyFilePath}");

    var outputDirectory = Path.GetDirectoryName(ksyFilePath) ?? Directory.GetCurrentDirectory();
    Console.WriteLine($"Output file directory: {outputDirectory}");

    processStartInfo.Arguments = $"-t csharp \"{ksyFilePath}\" --outdir \"{outputDirectory}\" --dotnet-namespace \"BoostStudio.Formats\"";

    using var process = Process.Start(processStartInfo);
    if (process is null)
    {
        Console.WriteLine("Failed to start the kaitai-struct-compiler process.");
        continue;
    }

    process.OutputDataReceived += (sender, e) =>
    {
        if (!string.IsNullOrEmpty(e.Data))
            Console.WriteLine(e.Data);
    };

    process.ErrorDataReceived += (sender, e) =>
    {
        if (!string.IsNullOrEmpty(e.Data))
            Console.WriteLine($"Error: {e.Data}");
    };

    process.Start();
    process.BeginOutputReadLine();
    process.BeginErrorReadLine();
    process.WaitForExit();

    var outputFilePath = Directory.GetFiles(outputDirectory, "*.cs")
        .OrderByDescending(f => File.GetLastWriteTime(f))
        .FirstOrDefault();

    if (!File.Exists(outputFilePath))
    {
        Console.WriteLine("No .cs file was generated.");
        continue;
    }

    Console.WriteLine($"Apply post processing to generated file: {outputFilePath}");
    await KsyPostProcessing(outputFilePath, outputFilePath);
}

static async Task KsyPostProcessing(string inputPath, string outputPath)
{
    var code = File.ReadAllText(inputPath);
    var tree = CSharpSyntaxTree.ParseText(code);
    var root = tree.GetRoot();

    // Create a new comment syntax node indicating that the file is auto-generated
    var autoGeneratedComment = SyntaxFactory.Comment(
        """

        //----------------------
        // <auto-generated>
        //     This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild
        // </auto-generated>
        //----------------------

        """
        );

    // Add the comment to the leading trivia of the root node
    root = root.WithLeadingTrivia(autoGeneratedComment);

    var rewriter = new AddSetterRewriter();
    var newRoot = rewriter.Visit(root);

    // Format the code
    newRoot = Formatter.Format(newRoot, new AdhocWorkspace());

    // Format the code
    var workspace = new AdhocWorkspace();
    var options = workspace.Options.WithChangedOption(
        FormattingOptions.NewLine,
        LanguageNames.CSharp,
        "\r\n"
    ); // Use Carriage Return + Line Feed (CRLF)
    var formattedNode = Formatter.Format(newRoot, workspace, options);

    var newCode = formattedNode.ToFullString();

    await File.WriteAllTextAsync(outputPath, newCode);
}

public class AddSetterRewriter : CSharpSyntaxRewriter
{
    public override SyntaxNode VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
    {
        if (node.Body is null)
        {
            Console.WriteLine("There's no body for this node!");
            return node;
        }

        // Add a new parameter of type bool with default value false
        var newParameter = SyntaxFactory
            .Parameter(SyntaxFactory.Identifier("write"))
            .WithType(
                SyntaxFactory.PredefinedType(
                    SyntaxFactory
                        .Token(SyntaxKind.BoolKeyword)
                        .WithTrailingTrivia(SyntaxFactory.Space)
                )
            )
            .WithDefault(
                SyntaxFactory.EqualsValueClause(
                    SyntaxFactory.LiteralExpression(SyntaxKind.FalseLiteralExpression)
                )
            );

        // Add the new parameter to the existing parameter list
        var newParameterList = node.ParameterList.AddParameters(newParameter);

        // Find the existing _read() call statement
        var oldStatement = node.Body.Statements.FirstOrDefault(s =>
            s
                is ExpressionStatementSyntax
            {
                Expression: InvocationExpressionSyntax
                {
                    Expression: IdentifierNameSyntax { Identifier.Text: "_read" }
                }
            }
        );

        if (oldStatement is null)
        {
            Console.WriteLine("oldStatement is null!");
            return node;
        }

        // Create a new if statement that checks the value of the write parameter
        var ifStatement = SyntaxFactory.IfStatement(
            SyntaxFactory.PrefixUnaryExpression(
                SyntaxKind.LogicalNotExpression,
                SyntaxFactory.IdentifierName("write")
            ),
            SyntaxFactory.ExpressionStatement(
                SyntaxFactory.InvocationExpression(SyntaxFactory.IdentifierName("_read"))
            )
        );

        // Replace the old statement with the new if statement
        var newBody = node.Body.ReplaceNode(oldStatement, ifStatement);

        // Modify assignments to boolean fields that start with "f_"
        var statements = newBody.Statements.Select(statement =>
        {
            if (
                statement is ExpressionStatementSyntax expressionStatement
                && expressionStatement.Expression is AssignmentExpressionSyntax assignment
                && assignment.Left is IdentifierNameSyntax identifier
                && identifier.Identifier.Text.StartsWith("f_")
                && assignment.Right is LiteralExpressionSyntax literal
                && literal.Token.Value is bool
            )
            {
                return statement.ReplaceNode(literal, SyntaxFactory.IdentifierName("write"));
            }

            return statement;
        });

        newBody = newBody.WithStatements(SyntaxFactory.List(statements));

        // Return a new constructor declaration with the new parameter list and body
        return node.WithParameterList(newParameterList).WithBody(newBody);
    }

    public override SyntaxNode VisitEnumDeclaration(EnumDeclarationSyntax node)
    {
        if (node.Identifier.Text.ToLower().Contains("uint".ToLower()))
        {
            return node.WithBaseList(
                    SyntaxFactory.BaseList(
                        SyntaxFactory.SingletonSeparatedList<BaseTypeSyntax>(
                            SyntaxFactory.SimpleBaseType(SyntaxFactory.ParseTypeName("uint"))
                        )
                    )
                )
                .WithLeadingTrivia(node.GetLeadingTrivia())
                .WithTrailingTrivia(node.GetTrailingTrivia());
        }
        return node;
    }

    public override SyntaxNode VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
        // Check if the property has a public accessor
        if (!node.Modifiers.Any(SyntaxKind.PublicKeyword))
            return node;

        // Get the name of the property
        var propertyName = node.Identifier.ValueText;

        // Get the name of the private backing field
        var fieldName = $"_{char.ToLower(propertyName[0])}{propertyName.Substring(1)}";

        switch (propertyName)
        {
            case "M_Root":
                fieldName = "m_root";
                break;
            case "M_Parent":
                fieldName = "m_parent";
                break;
            case "M_RawBody":
                fieldName = "__raw_body";
                break;
        }

        // Create a setter accessor with an assignment statement
        var setter = SyntaxFactory
            .AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
            .WithBody(
                SyntaxFactory.Block(
                    SyntaxFactory.ExpressionStatement(
                        SyntaxFactory.AssignmentExpression(
                            SyntaxKind.SimpleAssignmentExpression,
                            SyntaxFactory.IdentifierName(fieldName),
                            SyntaxFactory.IdentifierName("value")
                        )
                    )
                )
            );

        // Add the setter to the existing accessors list
        var accessors = node.AccessorList?.AddAccessors(setter);

        // Return the modified property declaration with the new accessor list
        return node.WithAccessorList(accessors);

        // Otherwise, return the original node
    }
}
