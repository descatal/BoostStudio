
//----------------------
// <auto-generated>
//     This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild
// </auto-generated>
//----------------------
using Kaitai;
using System.Collections.Generic;

namespace BoostStudio.Formats
{
    public partial class Psarc : KaitaiStruct
    {
        public static Psarc FromFile(string fileName)
        {
            return new Psarc(new KaitaiStream(fileName));
        }


        public enum CompressionType
        {
            None = 0,
            Lzma = 1819962721,
            Zlib = 2053925218,
        }
        public Psarc(KaitaiStream p__io, KaitaiStruct p__parent = null, Psarc p__root = null, bool write = false) : base(p__io)
        {
            m_parent = p__parent;
            m_root = p__root ?? this;
            if (!write)
                _read();
        }
        private void _read()
        {
            _header = new TocHeader(m_io, this, m_root);
            __raw_tables = m_io.ReadBytes((Header.TocSize - 32));
            var io___raw_tables = new KaitaiStream(__raw_tables);
            _tables = new TocTables(io___raw_tables, this, m_root);
        }
        public partial class TocHeader : KaitaiStruct
        {
            public static TocHeader FromFile(string fileName)
            {
                return new TocHeader(new KaitaiStream(fileName));
            }

            public TocHeader(KaitaiStream p__io, Psarc p__parent = null, Psarc p__root = null, bool write = false) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                if (!write)
                    _read();
            }
            private void _read()
            {
                _magic = m_io.ReadBytes(4);
                if (!((KaitaiStream.ByteArrayCompare(Magic, new byte[] { 80, 83, 65, 82 }) == 0)))
                {
                    throw new ValidationNotEqualError(new byte[] { 80, 83, 65, 82 }, Magic, M_Io, "/types/toc_header/seq/0");
                }
                _versionMajor = m_io.ReadU2be();
                _versionMinor = m_io.ReadU2be();
                _compressionType = ((Psarc.CompressionType)m_io.ReadU4be());
                _tocSize = m_io.ReadU4be();
                _tocEntrySize = m_io.ReadU4be();
                _tocEntries = m_io.ReadU4be();
                _blockSize = m_io.ReadU4be();
                _archiveFlags = m_io.ReadU4be();
            }
            private byte[] _magic;
            private ushort _versionMajor;
            private ushort _versionMinor;
            private CompressionType _compressionType;
            private uint _tocSize;
            private uint _tocEntrySize;
            private uint _tocEntries;
            private uint _blockSize;
            private uint _archiveFlags;
            private Psarc m_root;
            private Psarc m_parent;
            public byte[] Magic
            {
                get { return _magic; }

                set
                {
                    _magic = value;
                }
            }
            public ushort VersionMajor
            {
                get { return _versionMajor; }

                set
                {
                    _versionMajor = value;
                }
            }
            public ushort VersionMinor
            {
                get { return _versionMinor; }

                set
                {
                    _versionMinor = value;
                }
            }
            public CompressionType CompressionType
            {
                get { return _compressionType; }

                set
                {
                    _compressionType = value;
                }
            }
            public uint TocSize
            {
                get { return _tocSize; }

                set
                {
                    _tocSize = value;
                }
            }
            public uint TocEntrySize
            {
                get { return _tocEntrySize; }

                set
                {
                    _tocEntrySize = value;
                }
            }
            public uint TocEntries
            {
                get { return _tocEntries; }

                set
                {
                    _tocEntries = value;
                }
            }
            public uint BlockSize
            {
                get { return _blockSize; }

                set
                {
                    _blockSize = value;
                }
            }
            public uint ArchiveFlags
            {
                get { return _archiveFlags; }

                set
                {
                    _archiveFlags = value;
                }
            }
            public Psarc M_Root
            {
                get { return m_root; }

                set
                {
                    m_root = value;
                }
            }
            public Psarc M_Parent
            {
                get { return m_parent; }

                set
                {
                    m_parent = value;
                }
            }
        }
        public partial class TocTables : KaitaiStruct
        {
            public static TocTables FromFile(string fileName)
            {
                return new TocTables(new KaitaiStream(fileName));
            }

            public TocTables(KaitaiStream p__io, Psarc p__parent = null, Psarc p__root = null, bool write = false) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                if (!write)
                    _read();
            }
            private void _read()
            {
                __raw_entries = new List<byte[]>();
                _entries = new List<TocEntry>();
                for (var i = 0; i < M_Root.Header.TocEntries; i++)
                {
                    __raw_entries.Add(m_io.ReadBytes(M_Root.Header.TocEntrySize));
                    var io___raw_entries = new KaitaiStream(__raw_entries[__raw_entries.Count - 1]);
                    _entries.Add(new TocEntry(io___raw_entries, this, m_root));
                }
                _blocks = new List<ushort>();
                {
                    var i = 0;
                    while (!m_io.IsEof)
                    {
                        _blocks.Add(m_io.ReadU2be());
                        i++;
                    }
                }
            }
            private List<TocEntry> _entries;
            private List<ushort> _blocks;
            private Psarc m_root;
            private Psarc m_parent;
            private List<byte[]> __raw_entries;
            public List<TocEntry> Entries
            {
                get { return _entries; }

                set
                {
                    _entries = value;
                }
            }
            public List<ushort> Blocks
            {
                get { return _blocks; }

                set
                {
                    _blocks = value;
                }
            }
            public Psarc M_Root
            {
                get { return m_root; }

                set
                {
                    m_root = value;
                }
            }
            public Psarc M_Parent
            {
                get { return m_parent; }

                set
                {
                    m_parent = value;
                }
            }
            public List<byte[]> M_RawEntries
            {
                get { return __raw_entries; }

                set
                {
                    _m_RawEntries = value;
                }
            }
        }
        public partial class TocEntry : KaitaiStruct
        {
            public static TocEntry FromFile(string fileName)
            {
                return new TocEntry(new KaitaiStream(fileName));
            }

            public TocEntry(KaitaiStream p__io, Psarc.TocTables p__parent = null, Psarc p__root = null, bool write = false) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                f_body = write;
                if (!write)
                    _read();
            }
            private void _read()
            {
                _nameDigest = m_io.ReadBytes(16);
                _startBlockIndex = m_io.ReadU4be();
                _size = m_io.ReadBitsIntBe(40);
                _offset = m_io.ReadBitsIntBe(40);
            }
            private bool f_body;
            private List<byte[]> _body;
            public List<byte[]> Body
            {
                get
                {
                    if (f_body)
                        return _body;
                    KaitaiStream io = M_Root.M_Io;
                    long _pos = io.Pos;
                    io.Seek(Offset);
                    __raw_body = new List<byte[]>();
                    _body = new List<byte[]>();
                    {
                        var i = 0;
                        byte[] M_;
                        do
                        {
                            M_ = io.ReadBytes(M_Root.Tables.Blocks[StartBlockIndex]);
                            __raw_body.Add(M_);
                            M_ = m_io.ProcessZlib(__raw_body[__raw_body.Count - 1]);
                            _body.Add(M_);
                            i++;
                        } while (!(Body.Count == Size));
                    }
                    io.Seek(_pos);
                    f_body = true;
                    return _body;
                }

                set
                {
                    _body = value;
                }
            }
            private byte[] _nameDigest;
            private uint _startBlockIndex;
            private ulong _size;
            private ulong _offset;
            private Psarc m_root;
            private Psarc.TocTables m_parent;
            private List<byte[]> __raw_body;
            public byte[] NameDigest
            {
                get { return _nameDigest; }

                set
                {
                    _nameDigest = value;
                }
            }
            public uint StartBlockIndex
            {
                get { return _startBlockIndex; }

                set
                {
                    _startBlockIndex = value;
                }
            }
            public ulong Size
            {
                get { return _size; }

                set
                {
                    _size = value;
                }
            }
            public ulong Offset
            {
                get { return _offset; }

                set
                {
                    _offset = value;
                }
            }
            public Psarc M_Root
            {
                get { return m_root; }

                set
                {
                    m_root = value;
                }
            }
            public Psarc.TocTables M_Parent
            {
                get { return m_parent; }

                set
                {
                    m_parent = value;
                }
            }
            public List<byte[]> M_RawBody
            {
                get { return __raw_body; }

                set
                {
                    __raw_body = value;
                }
            }
        }
        private TocHeader _header;
        private TocTables _tables;
        private Psarc m_root;
        private KaitaiStruct m_parent;
        private byte[] __raw_tables;
        public TocHeader Header
        {
            get { return _header; }

            set
            {
                _header = value;
            }
        }
        public TocTables Tables
        {
            get { return _tables; }

            set
            {
                _tables = value;
            }
        }
        public Psarc M_Root
        {
            get { return m_root; }

            set
            {
                m_root = value;
            }
        }
        public KaitaiStruct M_Parent
        {
            get { return m_parent; }

            set
            {
                m_parent = value;
            }
        }
        public byte[] M_RawTables
        {
            get { return __raw_tables; }

            set
            {
                _m_RawTables = value;
            }
        }
    }
}
