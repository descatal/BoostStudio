
//----------------------
// <auto-generated>
//     This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild
// </auto-generated>
//----------------------
using Kaitai;
using System.Collections.Generic;

namespace BoostStudio.Formats
{
    public partial class Fhm : KaitaiStruct
    {

        public enum AssetLoadEnum
        {
            Normal = 0,
            Image = 1,
            Model = 2,
            Unknown = 3,
        }

        public enum UnkEnum
        {
            Unknown = 0,
        }

        public enum FileMagicEnums
        {
            Fhm = 1179143456,
        }
        public Fhm(uint p_binarySize, KaitaiStream p__io, KaitaiStruct p__parent = null, Fhm p__root = null, bool write = false) : base(p__io)
        {
            m_parent = p__parent;
            m_root = p__root ?? this;
            _binarySize = p_binarySize;
            if (!write)
                _read();
        }
        private void _read()
        {
            __raw_body = m_io.ReadBytesFull();
            var io___raw_body = new KaitaiStream(__raw_body);
            _body = new FileBody(BinarySize, io___raw_body, this, m_root);
        }
        public partial class FhmFile : KaitaiStruct
        {
            public FhmFile(int p_index, KaitaiStream p__io, Fhm.FhmBody p__parent = null, Fhm p__root = null, bool write = false) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _index = p_index;
                f_assetLoadType = write;
                f_unkType = write;
                f_size = write;
                f_body = write;
                f_offset = write;
                if (!write)
                    _read();
            }
            private void _read()
            {
            }
            private bool f_assetLoadType;
            private AssetLoadEnum _assetLoadType;
            public AssetLoadEnum AssetLoadType
            {
                get
                {
                    if (f_assetLoadType)
                        return _assetLoadType;
                    _assetLoadType = (AssetLoadEnum)(M_Parent.FileAssetLoadTypes[Index]);
                    f_assetLoadType = true;
                    return _assetLoadType;
                }

                set
                {
                    _assetLoadType = value;
                }
            }
            private bool f_unkType;
            private UnkEnum _unkType;
            public UnkEnum UnkType
            {
                get
                {
                    if (f_unkType)
                        return _unkType;
                    _unkType = (UnkEnum)(M_Parent.FileUnkTypes[Index]);
                    f_unkType = true;
                    return _unkType;
                }

                set
                {
                    _unkType = value;
                }
            }
            private bool f_size;
            private int _size;
            public int Size
            {
                get
                {
                    if (f_size)
                        return _size;
                    _size = (int)((M_Parent.FileSizes[Index] == 0 ? (M_Parent.NumFiles != (Index + 1) ? (M_Parent.FileOffsets[(Index + 1)] - M_Parent.FileOffsets[Index]) : (M_Parent.SectionSize - M_Parent.FileOffsets[Index])) : M_Parent.FileSizes[Index]));
                    f_size = true;
                    return _size;
                }

                set
                {
                    _size = value;
                }
            }
            private bool f_body;
            private FileBody _body;
            public FileBody Body
            {
                get
                {
                    if (f_body)
                        return _body;
                    long _pos = m_io.Pos;
                    m_io.Seek(Offset);
                    __raw_body = m_io.ReadBytes(((uint)(Size)));
                    var io___raw_body = new KaitaiStream(__raw_body);
                    _body = new FileBody(((uint)(Size)), io___raw_body, this, m_root);
                    m_io.Seek(_pos);
                    f_body = true;
                    return _body;
                }

                set
                {
                    _body = value;
                }
            }
            private bool f_offset;
            private uint _offset;
            public uint Offset
            {
                get
                {
                    if (f_offset)
                        return _offset;
                    _offset = (uint)(M_Parent.FileOffsets[Index]);
                    f_offset = true;
                    return _offset;
                }

                set
                {
                    _offset = value;
                }
            }
            private int _index;
            private Fhm m_root;
            private Fhm.FhmBody m_parent;
            private byte[] __raw_body;
            public int Index
            {
                get { return _index; }

                set
                {
                    _index = value;
                }
            }
            public Fhm M_Root
            {
                get { return m_root; }

                set
                {
                    m_root = value;
                }
            }
            public Fhm.FhmBody M_Parent
            {
                get { return m_parent; }

                set
                {
                    m_parent = value;
                }
            }
            public byte[] M_RawBody
            {
                get { return __raw_body; }

                set
                {
                    __raw_body = value;
                }
            }
        }
        public partial class UintZero : KaitaiStruct
        {
            public static UintZero FromFile(string fileName)
            {
                return new UintZero(new KaitaiStream(fileName));
            }

            public UintZero(KaitaiStream p__io, Fhm.FhmBody p__parent = null, Fhm p__root = null, bool write = false) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                if (!write)
                    _read();
            }
            private void _read()
            {
                _zero = m_io.ReadBytes(4);
                if (!((KaitaiStream.ByteArrayCompare(Zero, new byte[] { 0, 0, 0, 0 }) == 0)))
                {
                    throw new ValidationNotEqualError(new byte[] { 0, 0, 0, 0 }, Zero, M_Io, "/types/uint_zero/seq/0");
                }
            }
            private byte[] _zero;
            private Fhm m_root;
            private Fhm.FhmBody m_parent;
            public byte[] Zero
            {
                get { return _zero; }

                set
                {
                    _zero = value;
                }
            }
            public Fhm M_Root
            {
                get { return m_root; }

                set
                {
                    m_root = value;
                }
            }
            public Fhm.FhmBody M_Parent
            {
                get { return m_parent; }

                set
                {
                    m_parent = value;
                }
            }
        }
        public partial class FhmBody : KaitaiStruct
        {
            public FhmBody(uint p_sectionSize, KaitaiStream p__io, Fhm.FileBody p__parent = null, Fhm p__root = null, bool write = false) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _sectionSize = p_sectionSize;
                f_files = write;
                if (!write)
                    _read();
            }
            private void _read()
            {
                _flag1 = m_io.ReadBytes(2);
                if (!((KaitaiStream.ByteArrayCompare(Flag1, new byte[] { 1, 1 }) == 0)))
                {
                    throw new ValidationNotEqualError(new byte[] { 1, 1 }, Flag1, M_Io, "/types/fhm_body/seq/0");
                }
                _flag2 = m_io.ReadBytes(2);
                if (!((KaitaiStream.ByteArrayCompare(Flag2, new byte[] { 0, 16 }) == 0)))
                {
                    throw new ValidationNotEqualError(new byte[] { 0, 16 }, Flag2, M_Io, "/types/fhm_body/seq/1");
                }
                _unkC = new UintZero(m_io, this, m_root);
                _totalFileSize = m_io.ReadU4be();
                _numFiles = m_io.ReadU4be();
                _fileOffsets = new List<uint>();
                for (var i = 0; i < NumFiles; i++)
                {
                    _fileOffsets.Add(m_io.ReadU4be());
                }
                _fileSizes = new List<uint>();
                for (var i = 0; i < NumFiles; i++)
                {
                    _fileSizes.Add(m_io.ReadU4be());
                }
                _fileAssetLoadTypes = new List<AssetLoadEnum>();
                for (var i = 0; i < NumFiles; i++)
                {
                    _fileAssetLoadTypes.Add(((Fhm.AssetLoadEnum)m_io.ReadU4be()));
                }
                _fileUnkTypes = new List<UnkEnum>();
                for (var i = 0; i < NumFiles; i++)
                {
                    _fileUnkTypes.Add(((Fhm.UnkEnum)m_io.ReadU4be()));
                }
            }
            private bool f_files;
            private List<FhmFile> _files;
            public List<FhmFile> Files
            {
                get
                {
                    if (f_files)
                        return _files;
                    _files = new List<FhmFile>();
                    for (var i = 0; i < NumFiles; i++)
                    {
                        _files.Add(new FhmFile(i, m_io, this, m_root));
                    }
                    f_files = true;
                    return _files;
                }

                set
                {
                    _files = value;
                }
            }
            private byte[] _flag1;
            private byte[] _flag2;
            private UintZero _unkC;
            private uint _totalFileSize;
            private uint _numFiles;
            private List<uint> _fileOffsets;
            private List<uint> _fileSizes;
            private List<AssetLoadEnum> _fileAssetLoadTypes;
            private List<UnkEnum> _fileUnkTypes;
            private uint _sectionSize;
            private Fhm m_root;
            private Fhm.FileBody m_parent;
            public byte[] Flag1
            {
                get { return _flag1; }

                set
                {
                    _flag1 = value;
                }
            }
            public byte[] Flag2
            {
                get { return _flag2; }

                set
                {
                    _flag2 = value;
                }
            }
            public UintZero UnkC
            {
                get { return _unkC; }

                set
                {
                    _unkC = value;
                }
            }
            public uint TotalFileSize
            {
                get { return _totalFileSize; }

                set
                {
                    _totalFileSize = value;
                }
            }
            public uint NumFiles
            {
                get { return _numFiles; }

                set
                {
                    _numFiles = value;
                }
            }
            public List<uint> FileOffsets
            {
                get { return _fileOffsets; }

                set
                {
                    _fileOffsets = value;
                }
            }
            public List<uint> FileSizes
            {
                get { return _fileSizes; }

                set
                {
                    _fileSizes = value;
                }
            }
            public List<AssetLoadEnum> FileAssetLoadTypes
            {
                get { return _fileAssetLoadTypes; }

                set
                {
                    _fileAssetLoadTypes = value;
                }
            }
            public List<UnkEnum> FileUnkTypes
            {
                get { return _fileUnkTypes; }

                set
                {
                    _fileUnkTypes = value;
                }
            }
            public uint SectionSize
            {
                get { return _sectionSize; }

                set
                {
                    _sectionSize = value;
                }
            }
            public Fhm M_Root
            {
                get { return m_root; }

                set
                {
                    m_root = value;
                }
            }
            public Fhm.FileBody M_Parent
            {
                get { return m_parent; }

                set
                {
                    m_parent = value;
                }
            }
        }
        public partial class GenericBody : KaitaiStruct
        {
            public static GenericBody FromFile(string fileName)
            {
                return new GenericBody(new KaitaiStream(fileName));
            }

            public GenericBody(KaitaiStream p__io, Fhm.FileBody p__parent = null, Fhm p__root = null, bool write = false) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                f_body = write;
                if (!write)
                    _read();
            }
            private void _read()
            {
            }
            private bool f_body;
            private byte[] _body;
            public byte[] Body
            {
                get
                {
                    if (f_body)
                        return _body;
                    _body = m_io.ReadBytesFull();
                    f_body = true;
                    return _body;
                }

                set
                {
                    _body = value;
                }
            }
            private Fhm m_root;
            private Fhm.FileBody m_parent;
            public Fhm M_Root
            {
                get { return m_root; }

                set
                {
                    m_root = value;
                }
            }
            public Fhm.FileBody M_Parent
            {
                get { return m_parent; }

                set
                {
                    m_parent = value;
                }
            }
        }
        public partial class FileBody : KaitaiStruct
        {
            public FileBody(uint p_sectionSize, KaitaiStream p__io, KaitaiStruct p__parent = null, Fhm p__root = null, bool write = false) : base(p__io)
            {
                m_parent = p__parent;
                m_root = p__root;
                _sectionSize = p_sectionSize;
                if (!write)
                    _read();
            }
            private void _read()
            {
                _fileMagic = ((Fhm.FileMagicEnums)m_io.ReadU4be());
                switch (FileMagic)
                {
                    case Fhm.FileMagicEnums.Fhm:
                        {
                            _fileContent = new FhmBody(SectionSize, m_io, this, m_root);
                            break;
                        }
                    default:
                        {
                            _fileContent = new GenericBody(m_io, this, m_root);
                            break;
                        }
                }
            }
            private FileMagicEnums _fileMagic;
            private KaitaiStruct _fileContent;
            private uint _sectionSize;
            private Fhm m_root;
            private KaitaiStruct m_parent;
            public FileMagicEnums FileMagic
            {
                get { return _fileMagic; }

                set
                {
                    _fileMagic = value;
                }
            }
            public KaitaiStruct FileContent
            {
                get { return _fileContent; }

                set
                {
                    _fileContent = value;
                }
            }
            public uint SectionSize
            {
                get { return _sectionSize; }

                set
                {
                    _sectionSize = value;
                }
            }
            public Fhm M_Root
            {
                get { return m_root; }

                set
                {
                    m_root = value;
                }
            }
            public KaitaiStruct M_Parent
            {
                get { return m_parent; }

                set
                {
                    m_parent = value;
                }
            }
        }
        private FileBody _body;
        private uint _binarySize;
        private Fhm m_root;
        private KaitaiStruct m_parent;
        private byte[] __raw_body;
        public FileBody Body
        {
            get { return _body; }

            set
            {
                _body = value;
            }
        }
        public uint BinarySize
        {
            get { return _binarySize; }

            set
            {
                _binarySize = value;
            }
        }
        public Fhm M_Root
        {
            get { return m_root; }

            set
            {
                m_root = value;
            }
        }
        public KaitaiStruct M_Parent
        {
            get { return m_parent; }

            set
            {
                m_parent = value;
            }
        }
        public byte[] M_RawBody
        {
            get { return __raw_body; }

            set
            {
                __raw_body = value;
            }
        }
    }
}
